# pley

Study project using dotnet core, react, postgres, Yelp style application.

## pre-requisites

You need to have postgres running. 

The following command will launce the application locally:

```bash
dotnet run
```

## secrets

For development, you can use the built in secrets dev tool.

```bash
# list all the secrets
dotnet user-secrets list
# set a secret
dotnet user-secrests add <key> <secret>
```

The two secrets needed to run this app are `JwtSecret`, a 256 bit string for JWT, and `DbConn`, the connection string to the postgres DB.

For production `appsettings.Production.json` is set up in ansible. There is an encrypted file in `ansible/group_vars/all/vault` containing the secrets. The secret to encrypt / decrypt this file is contained in `.secret` (which is excluded from git).

## database

When first running, you would need to run the migration.

``` 
dotnet ef database update
```

The database will be seeded with one user, with the login `admin@example.com` and password `password`.

### Migrating db changes to production.

I set up an RDS database in AWS.

I could not find a good way to push ef migrations to prd. I could create a script, using this command, and subsequently execute the script agains the prd database.

```
dotnet ef migrations script -o scripts/2020-04-12-a.sql
'/Applications/Postgres.app/Contents/Versions/9.3/bin'/psql --host pley.c0hsbt7jwzl0.us-east-1.rds.amazonaws.com  -p5432 --user postgres
```

### Configure EC2 to talk to database

On the database security group, add an inbound rule.

For port 5432 (Postgres) allow ingress from the security group assigned to the EC2 instance. One generated by terraform.

See below for automated command to set this up.

## Deployment

### Build infrastructure

Prerequisite: 
- install terraform
- execute `terraform init` in infra folder

```bash
cd infra
~/terraform apply -auto-approve

# apply ingress rule to RDS security group
aws ec2 authorize-security-group-ingress --group-id sg-04274a416689ad304 --protocol tcp --port 5432 --source-group $(~/terraform output -json instance_sg_id | jq -r '.')

# remove security group
aws ec2 authorize-security-group-ingress --group-id sg-04274a416689ad304 --protocol tcp --port 5432 --source-group $(~/terraform output -json instance_sg_id | jq -r '.')

# when done, you can destroy infra
~/terraform destroy -auto-approve
```

### Publish and deploy app

Publish ready for production, and manually push to server:

Note that `$(~/terraform output -json instance_ips | jq -r '.[0]')` will get the IP address of the instance that has been provisioned, based on the terraform output.

```bash
# publish
dotnet publish -r linux-x64 -c Release /p:PublishSingleFile=true

# deployment (manual)
# push executable and settings files
scp ./bin/Release/netcoreapp3.1/linux-x64/publish/appsettings* centos@$(~/terraform output -json instance_ips | jq -r '.[0]'):/home/centos
scp ./bin/Release/netcoreapp3.1/linux-x64/publish/Pley centos@$(~/terraform output -json instance_ips | jq -r '.[0]'):/home/centos
# the front end needs to be moved separately
# push content of ClientApp/build to ClientApp/build on server
ssh centos@$(~/terraform output -json instance_ips | jq -r '.[0]') 'mkdir -p ClientApp/build'
scp ./ClientApp/build/* centos@x.x.x.x:/home/centos/ClientApp/build
# ssh into box and start app
ssh centos@x.x.x.x
pwd
cd /home/centos
./Pley
```

Automated deployment with ansible

Prerequisite:
- ansible installed
- private key available on workstation (olivier's macbook .ssh)

```bash
ansible-playbook --vault-password-file ../.secret -i $(~/terraform output -json instance_ips | jq -r '.[0]'), ../ansible/provision.yml
```

### To do
- dotnet error when trying to check user error
- set up logging with cloudwatch ??
- clean up - specific user for webapp and service
- get nginx handler to work, use handler for pley app as well
- ssh?? letsencrypt??
